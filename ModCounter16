CHIP ModCounter16 {
    IN  in[16],       // modulo N
        init[16],     // valor inicial
        load,         // cargar init
        rst;          // reset
    OUT out[16],      // contador actual
        wrap;         // se activa al reinicio
//curr es el puntero o indice
//wrap es la regla de comportamiento
//Si wrap = 1 verdadero
//si wrap= 0 falso
    PARTS:

    // =========================
    // Registro del contador
    // =========================
    Register(in=nextVal, load=true, out=curr);

    // =========================
    // Comparar curr con N-1 para activar wrap
    // =========================
    // Nminus1 = in - 1
    Not16(in=false, out=minus1);          // 0xFFFF = -1
    Add16(a=in, b=minus1, out=Nminus1);

    // XOR curr vs N-1
    Xor(a=curr[0],  b=Nminus1[0],  out=d0);
    Xor(a=curr[1],  b=Nminus1[1],  out=d1);
    Xor(a=curr[2],  b=Nminus1[2],  out=d2);
    Xor(a=curr[3],  b=Nminus1[3],  out=d3);
    Xor(a=curr[4],  b=Nminus1[4],  out=d4);
    Xor(a=curr[5],  b=Nminus1[5],  out=d5);
    Xor(a=curr[6],  b=Nminus1[6],  out=d6);
    Xor(a=curr[7],  b=Nminus1[7],  out=d7);
    Xor(a=curr[8],  b=Nminus1[8],  out=d8);
    Xor(a=curr[9],  b=Nminus1[9],  out=d9);
    Xor(a=curr[10], b=Nminus1[10], out=d10);
    Xor(a=curr[11], b=Nminus1[11], out=d11);
    Xor(a=curr[12], b=Nminus1[12], out=d12);
    Xor(a=curr[13], b=Nminus1[13], out=d13);
    Xor(a=curr[14], b=Nminus1[14], out=d14);
    Xor(a=curr[15], b=Nminus1[15], out=d15);

    // OR construido en un árbol para detectar igualdad
    Or(a=d0, b=d1, out=o1);
    Or(a=d2, b=d3, out=o2);
    Or(a=d4, b=d5, out=o3);
    Or(a=d6, b=d7, out=o4);
    Or(a=d8, b=d9, out=o5);
    Or(a=d10, b=d11, out=o6);
    Or(a=d12, b=d13, out=o7);
    Or(a=d14, b=d15, out=o8);

    Or(a=o1, b=o2, out=o9);
    Or(a=o3, b=o4, out=o10);
    Or(a=o5, b=o6, out=o11);
    Or(a=o7, b=o8, out=o12);

    Or(a=o9, b=o10, out=o13);
    Or(a=o11, b=o12, out=o14);

    Or(a=o13, b=o14, out=diff);

    Not(in=diff, out=wrap);  // wrap=1 cuando curr == N-1

    // =========================
    // Incremento
    // =========================
    Inc16(in=curr, out=incVal);

    // Si wrap → reiniciar a 0
    Mux16(a=incVal, b=false, sel=wrap, out=afterMod);

    // Si load=1 → cargar init
    Mux16(a=afterMod, b=init, sel=load, out=afterLoad);

    // Si rst=1 → reiniciar a 0
    Mux16(a=afterLoad, b=false, sel=rst, out=nextVal);

    // Salida final
    And16(a=curr, b=true, out=out);
